#! /usr/bin/env python
# -*- coding: utf-8 -*-

import imp
import inspect
import glob
import curses
import os
import os.path as osp
import re
import sys

import yaml


# Helpers
def load_module(filename, condition=None, required=[]):
	"""
	Returns a mapping between all the names defined in the module
	pointed by `filename` and their corresponding values
	"""
	
	if condition is None:
		condition = lambda x: True
	
	# Convention over the module name
	modname = '_ctask_%s' % osp.splitext(filename)[0]
	
	# Load the module
	try: modobj = imp.load_source(modname, filename)
	except Exception as e:
		# TODO encapsulate the line with problems in a custom exception
		# and prepare subsequent code to handle it
		raise e
	
	# Dump the list of public names
	namelist = filter(lambda s: not s.startswith('_'), dir(modobj))
	
	# Check the required names defined in config
	for name in required:
		if name not in namelist:
			raise ValueError("module '%s' does not define '%s'" % (modname, name))
	
	# Collect the public names into a namespace and return
	namespace = {}
	for name in namelist:
		obj = getattr(modobj, name)
		if condition(obj):
			namespace[name] = obj
	
	return namespace


def load_tasks(directories):
	"""
	Returns a mapping of all the tasks loaded from all the .py files
	from all the directories (in the `directories` list)
	"""
	
	tasks = {}
	condition = lambda obj: getattr(obj, '_task', False)
	
	for directory in directories:
		for filename in glob.iglob(osp.join(directory, '*.py')):
			try: names = load_module(filename, condition)
			except Exception as e:
				e.filename = filename
				raise e
			else:
				tasks.update(names)
	return tasks


def recurse_up(directory, filename):
	"""
	Recursive walk a directory up to root until it contains `filename`
	"""

	directory = osp.abspath(directory)

	while True:
		searchfile = osp.join(directory, filename)

		if osp.isfile(searchfile):
			return directory

		if directory == '/': break
		else: directory = osp.dirname(directory)
	return False

def puts(*args, **kwargs):
	"""
	Prints each argument on a separte line color (highlighted and trimmed for tty)
	"""

	# TODO: generalize
	# trim   = kwargs.get('trim') is not False
	# color  = kwargs.get('color') is not False
	# stream = kwargs.get('stream') or sys.stdout

	# stringify args
	args = [str(i) for i in args]

	# helpers
	Fore = {
			'BLACK': '\x1b[30m',
			'RED': '\x1b[31m',
			'GREEN': '\x1b[32m',
			'YELLOW': '\x1b[33m',
			'BLUE': '\x1b[34m',
			'MAGENTA': '\x1b[35m',
			'CYAN': '\x1b[36m',
			'WHITE': '\x1b[37m',
			'RESET': '\x1b[39m',
			}

	def replace(ansi = True):
		def func(mobj):
			color = Fore.get(mobj.group(1).upper())
			if color:
				if ansi: return color
				else: return ''
			else: return mobj.group(0)
		return func

	def trim(ansi, width):
		string = ''; size = 0; i = 0

		while i < len(ansi):
			mobj = re.match('\x1b[^m]*m', ansi[i:])
			if mobj:
				# append ansi code
				string = string + mobj.group(0)
				i += len(mobj.group(0))
			else:
				# loop for more ansi codes even at max width
				size += 1
				if size > width: break

				# append normal char
				string = string + ansi[i]
				i += 1
		return string

	# process strings
	if not sys.stdout.isatty():
		# remove ansi codes and print
		for string in args:
			print(re.sub('{(.+?)}', replace(False), string))
	else:
		# get terminal width
		try: curses.setupterm()
		except: width = float('inf')
		else: width = curses.tigetnum('cols')

		# trim string
		for string in args:
			string =  re.sub('{(.+?)}', replace(True), string)

			trimmed = trim(string, width)
			if len(trimmed) < len(string):
				trimmed = trim(string, width - 3) + '...'
			print(trimmed + Fore['RESET'])

# Main program
if __name__ == '__main__':

	# Find project root
	root = recurse_up(os.getcwd(), 'Cakefile')
	if not root:
		puts('{red}cake aborted!', 'No Cakefile found')
		exit(-1)
	else:
		puts("{yellow}(in %s)" % root)

	# Load all tasks
	cakefile = osp.join(root, 'Cakefile')
	with open(cakefile) as f:
		conf = yaml.load(f) or {}

	if type(conf) != dict:
		puts('{red}cake aborted!', 'Cakefile is not valid YAML')
		exit(-1)
	
	dirs = conf.get('TASKDIRS')
	if not dirs:
		puts('{red}cake aborted!', 'Cakefile does not define `TASKDIRS`')
		exit(-1)

	if [i for i in dirs if type(i) != str]:
		puts('{red}cake aborted!', 'Cakefile `TASKDIRS` should be a list of strings')
		exit(-1)

	dirs = [osp.join(root, i) for i in dirs]
	try: tasks = load_tasks(dirs)
	except Exception as e:
		puts('{red}cake aborted!', "%s: %s" % (e.filename.replace(root + '/', ""), e))
		exit(-1)

	# Check arguments
	if len(sys.argv) <= 1:
		# Calculate specs and max spec width
		specformat = '{cyan}%s {reset}%s'
		width = 40 + len('{cyan}{reset}')

		for name, task in tasks.items():
			params = inspect.formatargspec(*inspect.getargspec(task))
			task._spec = specformat % (name, params if params != '()' else '')
			width = max(width, len(task._spec))

		# List all tasks
		for task in tasks.values():
			puts("cake %-*s # %s" % (width, task._spec, re.sub('\s+', ' ', task._desc)))
	else:
		# Execute task
		taskname   = sys.argv[1]
		args       = [i for i in sys.argv[2:] if i.find('=') == -1]
		kwargs     = dict([i.split('=') for i in sys.argv[2:] if i.find('=') != -1])

		task = tasks.get(taskname)
		if task:
			try: task(*args, **kwargs)
			except TypeError as e:
				puts('{red}cake aborted!', e)
		else:
			puts('{red}cake aborted!', "Task {cyan}%s{reset} not found" % taskname)

